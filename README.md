# my-first-repo
My Project Repository

This is my first games programming project, likely in Javascript or Unreal Engine, and this is some <code>code for the project</code> As this course progresses so too I am hoping will my ability to programme a really cool game. I'm currently thinking along the lines of a narrative that allows for several digressions from the main story arc, with user-driven control over story setting and narrative. The primary aim of this game will likely marry digital literacy with the humanities to establish a bridge or confluence of two worlds — a principle that has worked extremely well in the past with respect to game development. I am also aspiring to create a game that can be played offline if, for no other reason, than to increase the likelihood of actual human interaction that will reflect computer-driven engagement. In this regard, I am examining how offline and traditional games are created (Monopoly, Cops and Robbers, Cricket etc.) to understand the deeper fundamentals of gameplay and game design. Ultimately, the practice of game-development is rooted in the principles of consumer engagement and consumer entertainment, and this I am hoping will serve as a mantra — to convert passive recipients of data, into active participants of information.


---10 October 2017---
Following with this thread I now have a clearer idea of what type of game I would like to build. I am interested in building one of two games (unless time and resources permit, in which case I will builf both games). The first and more ambitious game will be a maze-like scenario built with jQuery and JavaScript. The game would involve a degree of strategy and planning — for example can a player move from one side of the maze to the other in the shortest possbile steps. An alternative scenario to this would be to create a bricks-like game where bricks from the top keep falling and moving tray / paddle at the bottom is controlled by the player to shoot left and right in order to catch the bricks and tip them into a safety bin before attempting to catch the next falling one. Variances in level design would include bricks falling faster and the safety bin getting smaller. The safety bin might also move position as the game progresses. I believe the simplicity of the game (and complexity of the code in JS / jQuery) might make this an idea console or mobile game and I will be shortly starting to build this out and sandbox it in a web browser. My index.html file here on Github will hold the commits for the code, while this readme file will continue to hold the analysis, plans, insights, learnings, and execution strategies.


So with basic setup getting underway I decided to do some organising for the team that will do this project. Some basic roles that I researched from a few games studios are: art director; graphics programmer; graphic designer; concept lead; project lead; animator; audio producer; level editor; devOps engineer. Of course having all of these positions in a small project is not feasible but nonetheless the identification of roles is the main thrust when co-ordinating a team with both designated and shared responsibilities. So while individuals for each role is out of the question, the organisation of a team of 3 to 4 will require that each team member assume a few roles from this list. For example the lead animator can also take on the responsibilities of art director and graphic designer. Likewise, the concept lead can assume the roles of project lead and devOps manager. I am starting to see that when producing a game, it is not just the hardware and software that come into play but the management of groups of professionals — each an expert at his/her job — to form a cohesive and well-functioning unit that collectively commits to the project's overall integrity. The whole is greater than the sum of its parts. I will be doing some research vis-a-vis building out the game into LEAN, AGILE, and DevOps. I feel this will be crucial to getting a more realistic feel for working in an actual games studio when the time comes.


Following up on the management aspect, I've decided to create a demo file (mobile format). I figured that when the game is produced, it will be useful to have a pre-existing framework through which to demo this to potential users. Since the index.html file contains the code of the game in HTML / JavaScript for primarily desktop consumption, I anticipate the number of users with mobile devices to access this game will be significant. I have therefore created a prototype mobile placeholder in the event I need to quickly demo this game. The name of the file is: game-demo-mobile.html. Since I currently lack any useable code at the moment, I have done a mock-up of an app-like system. I may or may not use this file at the end, but I feel it is beneficial to have it, if not for anything else than to become even more familiar and confident using Github respositories to hold multiple mini projects.


Today I managed to do something that seemed extremely difficult and dangerous for my files and content - I learned how to change my repo name. The process, as it turns out a lot when learning a new skill, was straightforward and logical. I simply clicked the settings button under the repo name. A tab opened with the option to rename the repo, together with a list of checkboxes to maintain and update all links. It worked perfectly and suddenly I am feeling a lot more confident using Github on a more regular basis. It's good to experiment at times and learning comes with risk. This exact same principle will be of immense use when designing my game. Feels good to learn and make progress.


Today Pedro (Andy Thomason's T.A.) introduced the concepts of coding within the frameworks of Unity and Unreal Engine 4. There was also an introduction to Blueprints. The session was incredibly useful, especially given its relevance to the game being designed. With greater knowledge of these platforms comes more ideas and — more importantly — greater ability to execute the idea. Therefore the ambition to create and design a more interesting game rises. Unity is great for smaller games while Unreal Engine is more towards console and PC. However the choice is determined not so much by the technology but by the ambition of the game and the technology stack the game creator is most comfortable with. The game concept comes first and the technology stack will come second. So in the case of the Snake Game, the concept of the growing snake (++ boxes for each stage of growth) it is important to understand how the gameplay will develop before choosing the programming language. That makes perfect sense from a games developer point of view.


The basic setup of snake is coming together in my index.html file. Using jQuery and HTML5 canvas I have setup the basic game structure and playground (canvas) within which the game will be played. In the next stage I will setup the necessary function to make the snake's body and its movement along the direction keypad. The variables and basic attributes of each have been defined but have not been linked by any functions as yet. I am assuming I will have to write a function to make these discrete components come together. To understand functions better I am consulting the book 'You Don't Know JS' by Kyle Simpson. Once I understand the concept better I will write up the function — and hopefully it works the first time.


Committing from this point on will be done via Sourcetree (whenever feasible and efficient). It was explained that while working on JavaScript and HTML-based games, the outdated (but still works) mode would be to test the game on an editor, like Atom, ensure everything works and then copy-paste the source code to the index.html file here on Github. However, when compiling gameplay on Unity or Unreal, every variable change will need to be recorded, which makes this method of commits obsolete and inefficient. Sourcetree solves this problem by running/recording these changes in the background so that there is commit entry at both ends — development and respository. This is extremely useful and I understand now the value of this practice and method within gaming studios and high-level co-ordination projects.


How to add a local repository to Sourcetree (Pedro's Recommendation to Research)
The process of adding a local repository to Sourcetree on Mac, as it turned out, was relatively simple, and after some searching online and experimenting with the app, I figured out how to do it. The steps are as follows:
1. Open Finder and locate the folder that you want to add
2. Open Sourcetree and locate the Bookmarks Window
3. Drag and drop the folder into Sourcetree's Bookmarks Window
4. On the pop-up prompt dialog box click 'Add Repository'
5. Navigate to the tab which says 'Add Working Copy'
6. Your local repository will be available
The process is useful when moving a repository from a local machine to Github (Sourcetree interface). However, it is better to create the repository (where feasible) from scratch on Github via Sourcetree to avoid any prior versions that may have been altered on the local machine but have not yet been uploaded. In this case, when a local repository is added to Sourcetree, Sourcetree will only receive the most up-to-date folder contents from the local machine.


